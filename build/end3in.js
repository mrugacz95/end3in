/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var end3in;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Body.ts":
/*!*********************!*\
  !*** ./src/Body.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* binding */ Circle),\n/* harmony export */   \"Polygon\": () => (/* binding */ Polygon),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"RegularPolygon\": () => (/* binding */ RegularPolygon)\n/* harmony export */ });\n/* unused harmony export Body */\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n/* harmony import */ var _Utlis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utlis */ \"./src/Utlis.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar Body = /** @class */ (function () {\n    function Body(x, y, mass, inertia, isStatic, rot, restitution, color) {\n        if (isStatic === void 0) { isStatic = false; }\n        if (rot === void 0) { rot = 0; }\n        if (restitution === void 0) { restitution = 0.5; }\n        if (color === void 0) { color = _Utlis__WEBPACK_IMPORTED_MODULE_1__.Utils.randomColor(); }\n        this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(x, y);\n        this.rot = rot;\n        this.isStatic = isStatic;\n        if (this.isStatic) {\n            this.massInv = 0;\n            this.inertiaInv = 0;\n        }\n        else {\n            this.massInv = 1 / mass;\n            this.inertiaInv = 1 / inertia;\n        }\n        this.restitution = restitution;\n        this.color = color;\n        this.v = _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2.ZERO;\n        this.omega = 0;\n        this.transformUpdateRequired = true;\n    }\n    Body.prototype.update = function (dt) {\n        this.pos = this.pos.add(this.v.scale(dt));\n        // this.rot += this.omega * dt;\n        this.transformUpdateRequired = true;\n    };\n    ;\n    Body.prototype.applyForce = function (fx, fy, px, py, dt) {\n        px = px - this.pos.x;\n        py = py - this.pos.y;\n        var tau = px * fy - py * fx;\n        var ax = fx * this.massInv;\n        var ay = fy * this.massInv;\n        this.applyAcceleration(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(ax, ay), tau, dt);\n    };\n    ;\n    Body.prototype.applyAcceleration = function (a, tau, dt) {\n        var alpha = tau * this.inertiaInv;\n        this.v = this.v.add(a.scale(dt));\n        this.omega += alpha * dt;\n    };\n    ;\n    Body.prototype.applyImpulse = function (P, r) {\n        if (this.isStatic) {\n            return;\n        }\n        this.v = this.v.sub(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(P.x * this.massInv, P.y * this.massInv));\n        // this.omega -= this.inertiaInv * r.cross(P);\n    };\n    ;\n    return Body;\n}());\n\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    function Polygon(points, x, y, mass, isStatic, rot) {\n        var _this = this;\n        var vertices = points.map(function (p) { return new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(p[0], p[1]); });\n        var maxR = (Math.max.apply(Math, vertices.map(function (v) { return (v.sqrtMagnitude()); })));\n        var inertia = (mass * maxR * maxR) / 2;\n        _this = _super.call(this, x, y, mass, inertia, isStatic, rot) || this;\n        _this.points = [];\n        _this._transformedPoints = [];\n        var area = 0;\n        for (var i = 0; i < vertices.length; i++) {\n            var point = vertices[i];\n            var next = vertices[i % vertices.length];\n            area += (point.x * next.y) - (point.y * next.x);\n        }\n        area /= 2.0;\n        _this.area = area;\n        var meanX = vertices.map(function (o) { return o.x; }).reduce(function (p, c) { return p + c; }, 0) / points.length;\n        var meanY = vertices.map(function (o) { return o.y; }).reduce(function (p, c) { return p + c; }, 0) / points.length;\n        for (var _i = 0, vertices_1 = vertices; _i < vertices_1.length; _i++) {\n            var point = vertices_1[_i];\n            _this.points.push(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(point.x - meanX, point.y - meanY));\n        }\n        return _this;\n    }\n    Object.defineProperty(Polygon.prototype, \"transformedPoints\", {\n        get: function () {\n            if (this.transformUpdateRequired === false) {\n                return this._transformedPoints;\n            }\n            for (var i = 0; i < this.points.length; i++) {\n                this._transformedPoints[i] = this.points[i].rotate(this.rot).add(this.pos);\n            }\n            this.transformUpdateRequired = false;\n            return this._transformedPoints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ;\n    Object.defineProperty(Polygon.prototype, \"transformedAxes\", {\n        get: function () {\n            var result = [];\n            for (var i = 0; i < this.transformedPoints.length; i++) {\n                var first = this.transformedPoints[i];\n                var second = this.transformedPoints[(i + 1) % this.transformedPoints.length];\n                result.push({ axis: second.sub(first), p1: first, p2: second });\n            }\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ;\n    Polygon.prototype.isInside = function (point) {\n        for (var _i = 0, _a = this.transformedAxes; _i < _a.length; _i++) {\n            var a = _a[_i];\n            var d = a.axis.cross(a.p2.sub(point));\n            if (d > 0)\n                return false;\n        }\n        return true;\n    };\n    return Polygon;\n}(Body));\n\nvar RegularPolygon = /** @class */ (function (_super) {\n    __extends(RegularPolygon, _super);\n    function RegularPolygon(num_of_vertices, radius, x, y, mass, isStatic, rot) {\n        var points = [];\n        for (var i = num_of_vertices - 1; i >= 0; i--) {\n            var pos_x = Math.cos(2.0 * Math.PI / num_of_vertices * i) * radius;\n            var pos_y = Math.sin(2.0 * Math.PI / num_of_vertices * i) * radius;\n            points.push([pos_x, pos_y]);\n        }\n        return _super.call(this, points, x, y, mass, isStatic, rot) || this;\n    }\n    ;\n    return RegularPolygon;\n}(Polygon));\n\nvar Rectangle = /** @class */ (function (_super) {\n    __extends(Rectangle, _super);\n    function Rectangle(width, height, x, y, mass, isStatic, rot) {\n        var points = [[-width / 2, height / 2],\n            [width / 2, height / 2],\n            [width / 2, -height / 2],\n            [-width / 2, -height / 2]];\n        return _super.call(this, points, x, y, mass, isStatic, rot) || this;\n    }\n    return Rectangle;\n}(Polygon));\n\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle(radius, x, y, mass, isStatic) {\n        var _this = this;\n        var inertia = 2 / (mass * radius * radius);\n        _this = _super.call(this, x, y, mass, inertia, isStatic) || this;\n        _this.radius = radius;\n        return _this;\n    }\n    Circle.prototype.isInside = function (point) {\n        return false;\n    };\n    return Circle;\n}(Body));\n\n\n\n//# sourceURL=webpack://end3in/./src/Body.ts?");

/***/ }),

/***/ "./src/Collision.ts":
/*!**************************!*\
  !*** ./src/Collision.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Collision\": () => (/* binding */ Collision)\n/* harmony export */ });\n/* unused harmony export CollisionManifold */\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n\n\nvar Collision = /** @class */ (function () {\n    function Collision() {\n    }\n    Collision.areAABBColliding = function (body1, body2) {\n        var body1MinX = Number.MAX_VALUE, body1MaxX = -Number.MAX_VALUE, body2MinX = Number.MAX_VALUE, body2MaxX = -Number.MAX_VALUE, body1MinY = Number.MAX_VALUE, body1MaxY = -Number.MAX_VALUE, body2MinY = Number.MAX_VALUE, body2MaxY = -Number.MAX_VALUE;\n        if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n            for (var _i = 0, _a = body1.transformedPoints; _i < _a.length; _i++) {\n                var p = _a[_i];\n                body1MinX = Math.min(body1MinX, p.x);\n                body1MaxX = Math.max(body1MaxX, p.x);\n                body1MinY = Math.min(body1MinY, p.y);\n                body1MaxY = Math.max(body1MaxY, p.y);\n            }\n        }\n        if (body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n            for (var _b = 0, _c = body2.transformedPoints; _b < _c.length; _b++) {\n                var p = _c[_b];\n                body2MinX = Math.min(body2MinX, p.x);\n                body2MaxX = Math.max(body2MaxX, p.x);\n                body2MinY = Math.min(body2MinY, p.y);\n                body2MaxY = Math.max(body2MaxY, p.y);\n            }\n        }\n        if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) {\n            body1MinX = body1.pos.x - body1.radius;\n            body1MaxX = body1.pos.x + body1.radius;\n            body1MinY = body1.pos.y - body1.radius;\n            body1MaxY = body1.pos.y + body1.radius;\n        }\n        if (body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) {\n            body2MinX = body2.pos.x - body2.radius;\n            body2MaxX = body2.pos.x + body2.radius;\n            body2MinY = body2.pos.y - body2.radius;\n            body2MaxY = body2.pos.y + body2.radius;\n        }\n        return body1MinX < body2MaxX &&\n            body1MaxX > body2MinX &&\n            body1MinY < body2MaxY &&\n            body1MaxY > body2MinY;\n    };\n    ;\n    Collision.projectCircle = function (normal, body1) {\n        var _a, _b;\n        var directionRadius = normal.normalize().scale(body1.radius);\n        var p1 = body1.pos.add(directionRadius);\n        var p2 = body1.pos.sub(directionRadius);\n        var max = p1.dot(normal);\n        var min = p2.dot(normal);\n        if (min > max) {\n            _a = [max, min], min = _a[0], max = _a[1];\n            _b = [p2, p1], p1 = _b[0], p2 = _b[1];\n        }\n        return { min: min, max: max, minPoint: p1, maxPoint: p2 };\n    };\n    Collision.projectPolygon = function (axis, body) {\n        var min = Number.MAX_VALUE;\n        var max = -Number.MAX_VALUE;\n        var minPoint;\n        var maxPoint;\n        for (var _i = 0, _a = body.transformedPoints; _i < _a.length; _i++) {\n            var point = _a[_i];\n            var projection = point.dot(axis);\n            if (min > projection) {\n                min = projection;\n                minPoint = point;\n            }\n            if (max < projection) {\n                max = projection;\n                maxPoint = point;\n            }\n        }\n        return { min: min, max: max, minPoint: minPoint, maxPoint: maxPoint };\n    };\n    Collision.calculateSAT = function (body1, body2) {\n        if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) {\n            if (body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n                return Collision.intersectCirclePolygon(body1, body2);\n            }\n            else if (body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) {\n                return Collision.intersectCircles(body1, body2);\n            }\n            else {\n                throw new Error(\"Colliding circle with \".concat(body2, \" is not implemented yet\"));\n            }\n        }\n        else if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n            if (body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n                return Collision.intersectPolygons(body1, body2);\n            }\n            else if (body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) {\n                var collisionManifold = Collision.intersectCirclePolygon(body2, body1);\n                if (collisionManifold) {\n                    collisionManifold.normal = collisionManifold.normal.inv();\n                }\n                return collisionManifold;\n            }\n            else {\n                throw new Error(\"Colliding polygon with \".concat(body2, \" is not implemented yet\"));\n            }\n        }\n        else {\n            throw new Error(\"Colliding \".concat(body1, \" with \").concat(body2, \" is not implemented yet\"));\n        }\n    };\n    Collision.intersectPolygons = function (body1, body2) {\n        var collisionNormal = null;\n        var depth = Number.MAX_VALUE;\n        for (var _i = 0, _a = [body1, body2]; _i < _a.length; _i++) {\n            var body = _a[_i];\n            for (var _b = 0, _c = body.transformedAxes; _b < _c.length; _b++) {\n                var axisWithPoints = _c[_b];\n                var axis = axisWithPoints.axis;\n                var normal = axis.normalize().normal();\n                var bProj = Collision.projectPolygon(normal, body1);\n                var oProj = Collision.projectPolygon(normal, body2);\n                // check overlap\n                if (bProj.max <= oProj.min ||\n                    bProj.min >= oProj.max) {\n                    return undefined;\n                }\n                var overlap = 0;\n                overlap = Math.min(bProj.max - oProj.min, oProj.max - bProj.min);\n                if (overlap < depth) {\n                    depth = overlap;\n                    collisionNormal = normal;\n                }\n            }\n        }\n        if (body1.pos.sub(body2.pos).dot(collisionNormal) > 0) {\n            collisionNormal = collisionNormal.inv();\n        }\n        return new CollisionManifold(body1, body2, collisionNormal, depth, _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2.ZERO, _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2.ZERO, 0);\n    };\n    Collision.intersectCirclePolygon = function (circle, polygon) {\n        var returnedNormal = null;\n        var returnedDepth = Number.MAX_VALUE;\n        for (var _i = 0, _a = polygon.transformedAxes; _i < _a.length; _i++) {\n            var axisWithPoints = _a[_i];\n            var axis = axisWithPoints.axis;\n            var normal_1 = axis.normal().normalize();\n            var cProj_1 = Collision.projectCircle(normal_1, circle);\n            var pProj_1 = Collision.projectPolygon(normal_1, polygon);\n            if (cProj_1.min >= pProj_1.max || pProj_1.min >= cProj_1.max) {\n                return undefined;\n            }\n            var axisDepth_1 = Math.min(cProj_1.max - pProj_1.min, pProj_1.max - cProj_1.min);\n            if (axisDepth_1 < returnedDepth) {\n                returnedDepth = axisDepth_1;\n                returnedNormal = normal_1;\n            }\n        }\n        var closestPoint = Collision.closestPointOnPolygon(circle.pos, polygon);\n        var normal = closestPoint.sub(circle.pos).normal().normalize();\n        var cProj = Collision.projectCircle(normal, circle);\n        var pProj = Collision.projectPolygon(normal, polygon);\n        if (cProj.min >= pProj.max || pProj.min >= cProj.max) {\n            return undefined;\n        }\n        var axisDepth = Math.min(cProj.max - pProj.min, pProj.max - cProj.min);\n        if (axisDepth < returnedDepth) {\n            returnedDepth = axisDepth;\n            returnedNormal = normal;\n        }\n        if (circle.pos.sub(polygon.pos).dot(returnedNormal) > 0) {\n            returnedNormal = returnedNormal.inv();\n        }\n        return new CollisionManifold(polygon, circle, returnedNormal, returnedDepth, _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2.ZERO, _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2.ZERO, 0);\n    };\n    Collision.closestPointOnPolygon = function (point, polygon) {\n        var closestPoint = polygon.transformedPoints[0];\n        var dist = Number.MAX_VALUE;\n        for (var _i = 0, _a = polygon.transformedPoints; _i < _a.length; _i++) {\n            var polygonPoint = _a[_i];\n            var newDist = polygonPoint.distance(point);\n            if (newDist < dist) {\n                newDist = dist;\n                closestPoint = polygonPoint;\n            }\n        }\n        return closestPoint;\n    };\n    Collision.intersectCircles = function (circle1, circle2) {\n        var dist = circle1.pos.distance(circle2.pos);\n        var radiusSum = circle1.radius + circle2.radius;\n        if (dist > radiusSum) {\n            return undefined;\n        }\n        var normal = circle1.pos.sub(circle2.pos);\n        var depth = radiusSum - dist;\n        if (circle1.pos.sub(circle2.pos).dot(normal) > 0) {\n            normal = normal.inv();\n        }\n        return new CollisionManifold(circle1, circle2, normal, depth, _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2.ZERO, _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2.ZERO, 0);\n    };\n    return Collision;\n}());\n\nvar CollisionManifold = /** @class */ (function () {\n    function CollisionManifold(body1, body2, normal, depth, contact1, contact2, contactCount) {\n        this.body1 = body1;\n        this.body2 = body2;\n        this.normal = normal;\n        this.depth = depth;\n        this.contact1 = contact1;\n        this.contact2 = contact2;\n        this.contactCount = contactCount;\n    }\n    return CollisionManifold;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Collision.ts?");

/***/ }),

/***/ "./src/Engine.ts":
/*!***********************!*\
  !*** ./src/Engine.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Engine\": () => (/* binding */ Engine)\n/* harmony export */ });\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n/* harmony import */ var _Collision__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Collision */ \"./src/Collision.ts\");\n\n\n\nvar Engine = /** @class */ (function () {\n    function Engine(debug, solver, iterations) {\n        if (debug === void 0) { debug = false; }\n        if (iterations === void 0) { iterations = 35; }\n        this.solver = solver;\n        this.dt = 1 / 60; // take dt from elapsed time\n        this.debug = debug;\n        this.g = 9.81;\n        this.gameObjects = [];\n        this.iterations = iterations;\n    }\n    ;\n    Engine.prototype.start = function () {\n        var self = this;\n        window.setInterval(function () {\n            self.update.call(self);\n        }, 1000 * self.dt);\n    };\n    ;\n    Engine.prototype.update = function () {\n        for (var it = 0; it < this.iterations; it++) {\n            for (var _i = 0, _a = this.gameObjects; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                if (obj.isStatic !== true) {\n                    obj.applyAcceleration(new _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2(0, this.g), 0, this.dt / this.iterations);\n                }\n            }\n            if (this.solver === 'impulse') {\n                this.impulseSolver();\n            }\n            else if (this.solver === 'translation') {\n                this.translationSolver();\n            }\n            for (var _b = 0, _c = this.gameObjects; _b < _c.length; _b++) {\n                var obj = _c[_b];\n                obj.update(this.dt / this.iterations);\n            }\n        }\n    };\n    ;\n    Engine.prototype.addBody = function (body) {\n        this.gameObjects.push(body);\n    };\n    ;\n    Engine.prototype.addAllBodies = function (bodies) {\n        for (var _i = 0, bodies_1 = bodies; _i < bodies_1.length; _i++) {\n            var body = bodies_1[_i];\n            this.addBody(body);\n        }\n    };\n    ;\n    Engine.prototype.translationSolver = function () {\n        for (var i = 0; i < this.gameObjects.length; i++) {\n            for (var j = i + 1; j < this.gameObjects.length; j++) {\n                var body1 = this.gameObjects[i];\n                var body2 = this.gameObjects[j];\n                if (body1.isStatic && body2.isStatic) {\n                    continue;\n                }\n                if (!_Collision__WEBPACK_IMPORTED_MODULE_2__.Collision.areAABBColliding(body1, body2)) {\n                    continue;\n                }\n                var collisionManifold = _Collision__WEBPACK_IMPORTED_MODULE_2__.Collision.calculateSAT(body1, body2);\n                if (collisionManifold) {\n                    if (body2.isStatic) {\n                        body1.pos = body1.pos.add(collisionManifold.normal.normalize().scale(-collisionManifold.depth));\n                    }\n                    else if (body1.isStatic) {\n                        body2.pos = body2.pos.add(collisionManifold.normal.normalize().scale(collisionManifold.depth));\n                    }\n                    else {\n                        body2.pos = body2.pos.add(collisionManifold.normal.normalize().scale(collisionManifold.depth / 2));\n                        body1.pos = body1.pos.add(collisionManifold.normal.normalize().scale(-collisionManifold.depth / 2));\n                    }\n                    this.resolveCollision(body1, body2, collisionManifold.normal);\n                }\n            }\n        }\n    };\n    Engine.prototype.resolveCollision = function (body1, body2, normal) {\n        var relativeVelocity = body2.v.sub(body1.v);\n        if (relativeVelocity.dot(normal) > 0) {\n            return;\n        }\n        var e = Math.min(body1.restitution, body2.restitution);\n        var j = -(1 + e) * relativeVelocity.dot(normal);\n        j /= body1.massInv + body2.massInv;\n        var impulse = normal.scale(j);\n        body1.v = body1.v.sub(impulse.scale(body1.massInv));\n        body2.v = body2.v.add(impulse.scale(body2.massInv));\n    };\n    Engine.prototype.impulseSolver = function () {\n        for (var i = 0; i < this.gameObjects.length; i++) {\n            for (var j = i + 1; j < this.gameObjects.length; j++) {\n                var body1 = this.gameObjects[i];\n                var body2 = this.gameObjects[j];\n                if (!_Collision__WEBPACK_IMPORTED_MODULE_2__.Collision.areAABBColliding(body1, body2)) {\n                    continue;\n                }\n                if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle && body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) { //TODO add more cases\n                    continue;\n                }\n                var collisionManifold = _Collision__WEBPACK_IMPORTED_MODULE_2__.Collision.calculateSAT(body1, body2);\n                if (collisionManifold) {\n                    var incident = collisionManifold.body1;\n                    var reference = collisionManifold.body2;\n                    // V + omega × r\n                    var penetratingVelocity = collisionManifold.body1.v\n                        .add(collisionManifold.contact1\n                        .normal()\n                        .scale(collisionManifold.body2.omega))\n                        .cross(collisionManifold.normal);\n                    var referenceVelocity = collisionManifold.body2.v\n                        .add(collisionManifold.body2.v\n                        .normal()\n                        .scale(collisionManifold.body2.omega))\n                        .cross(collisionManifold.normal);\n                    var relativeVelocity = penetratingVelocity - referenceVelocity;\n                    var sign = Math.sign(relativeVelocity);\n                    relativeVelocity = Math.abs(relativeVelocity);\n                    var rn1 = collisionManifold.contact1.cross(collisionManifold.normal);\n                    var rn2 = collisionManifold.contact2.cross(collisionManifold.normal);\n                    var k = collisionManifold.body1.massInv + collisionManifold.body2.massInv;\n                    k += collisionManifold.body1.inertiaInv * (rn1 * rn1);\n                    k += collisionManifold.body2.inertiaInv * (rn2 * rn2);\n                    var slop = 0.02;\n                    var bias = 0.2 / this.dt * Math.max(collisionManifold.depth - slop, 0);\n                    var P = (relativeVelocity + sign * bias) / k;\n                    var Pvec = collisionManifold.normal.scale(P).normal();\n                    var refVector = Pvec.scale(sign);\n                    var indVector = Pvec.scale(-1 * sign);\n                    incident.applyImpulse(indVector, collisionManifold.contact1);\n                    reference.applyImpulse(refVector, collisionManifold.contact2);\n                }\n            }\n        }\n    };\n    ;\n    return Engine;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Engine.ts?");

/***/ }),

/***/ "./src/Graphics.ts":
/*!*************************!*\
  !*** ./src/Graphics.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graphics\": () => (/* binding */ Graphics)\n/* harmony export */ });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n\n\nvar Graphics = /** @class */ (function () {\n    function Graphics(_a) {\n        var width = _a.width, height = _a.height, engine = _a.engine, _b = _a.debug, debug = _b === void 0 ? false : _b, _c = _a.scale, scale = _c === void 0 ? 60 : _c, _d = _a.cameraPos, cameraPos = _d === void 0 ? new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(3, 3) : _d, _e = _a.clickCallback, clickCallback = _e === void 0 ? (function (_) {\n        }) : _e;\n        this.started = false;\n        this.width = width;\n        this.height = height;\n        this.engine = engine;\n        this.debug = debug;\n        this.canvas = document.createElement('canvas');\n        document.body.appendChild(this.canvas);\n        var self = this;\n        document.addEventListener(\"click\", function (event) {\n            var worldPos = self.clientToWorldPos(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(event.clientX, event.clientY));\n            clickCallback(worldPos);\n        });\n        this.ctx = this.canvas.getContext('2d');\n        this.scale = scale;\n        this.cameraPos = cameraPos;\n        this.width = 10 * this.scale;\n        this.height = 10 * this.scale;\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        this.dt = 1 / 60;\n    }\n    Graphics.prototype.start = function () {\n        this.started = true;\n        this.setInterval();\n    };\n    ;\n    Graphics.prototype.setInterval = function () {\n        if (!this.started) {\n            return;\n        }\n        var self = this;\n        setTimeout(function () {\n            self.drawBodies(self.engine.gameObjects);\n            self.setInterval();\n        }, 1000 * this.dt);\n    };\n    Graphics.prototype.stop = function () {\n        this.started = false;\n    };\n    Graphics.prototype.drawBodies = function (bodies) {\n        if (bodies === void 0) { bodies = this.engine.gameObjects; }\n        this.clear();\n        this.ctx.save();\n        this.ctx.scale(this.scale, this.scale);\n        this.ctx.translate(this.cameraPos.x, this.cameraPos.y);\n        for (var _i = 0, bodies_1 = bodies; _i < bodies_1.length; _i++) {\n            var body = bodies_1[_i];\n            this.drawBody(body, this.debug);\n        }\n        this.ctx.restore();\n    };\n    Graphics.prototype.clear = function () {\n        this.ctx.fillStyle = \"#FFFFFF\";\n        this.ctx.fillRect(0, 0, this.width, this.height);\n        this.ctx.fillStyle = \"#000000\";\n    };\n    ;\n    Graphics.prototype.drawBody = function (body, debug) {\n        if (body instanceof _Body__WEBPACK_IMPORTED_MODULE_1__.Polygon) {\n            this.ctx.beginPath();\n            for (var i = 0; i < body.points.length + 1; i++) {\n                var next = body.points[i % body.points.length]\n                    .rotate(body.rot)\n                    .transpose(body.pos.x, body.pos.y);\n                if (i === 0) {\n                    this.ctx.moveTo(next.x, next.y);\n                }\n                else {\n                    this.ctx.lineTo(next.x, next.y);\n                }\n            }\n            this.ctx.fillStyle = body.color;\n            this.ctx.fill();\n            if (debug) {\n                for (var _i = 0, _a = body.transformedAxes; _i < _a.length; _i++) {\n                    var axis = _a[_i];\n                    var mid = axis.axis.scale(0.5).add(axis.p1);\n                    var norm = axis.axis.normal();\n                    this.ctx.lineWidth = 1 / this.scale;\n                    this.ctx.strokeStyle = \"#7a7a7a\";\n                    this.ctx.beginPath();\n                    this.ctx.moveTo(mid.x, mid.y);\n                    this.ctx.lineTo(mid.x + norm.x, mid.y + norm.y);\n                    this.ctx.stroke();\n                }\n            }\n        }\n        else if (body instanceof _Body__WEBPACK_IMPORTED_MODULE_1__.Circle) {\n            this.ctx.lineWidth = 1 / this.scale;\n            this.ctx.fillStyle = body.color;\n            this.ctx.beginPath();\n            this.ctx.arc(body.pos.x, body.pos.y, body.radius, 0, 2 * Math.PI);\n            this.ctx.fill();\n        }\n    };\n    Graphics.prototype.clientToWorldPos = function (clientPos) {\n        var _a = this.canvas.getBoundingClientRect(), top = _a.top, left = _a.left;\n        return new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(clientPos.x, clientPos.y)\n            .sub(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(top, left))\n            .scale(1 / this.scale)\n            .sub(this.cameraPos);\n    };\n    Graphics.prototype.worldToCanvasPosition = function (worldPos) {\n        return worldPos.scale(this.scale);\n    };\n    return Graphics;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Graphics.ts?");

/***/ }),

/***/ "./src/Solver.ts":
/*!***********************!*\
  !*** ./src/Solver.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Solver\": () => (/* binding */ Solver)\n/* harmony export */ });\nvar Solver = /** @class */ (function () {\n    function Solver() {\n    }\n    Solver.solve = function (mat, b, iterations) {\n        // Ax = b\n        var x = [];\n        for (var i = 0; i < mat.length; i++) {\n            x.push(0);\n        }\n        for (var iter = 0; iter < iterations; iter++) {\n            for (var i = 0; i < mat.length; i++) {\n                var sum = b[i];\n                for (var j = 0; j < mat[i].length; j++) {\n                    if (j !== i) {\n                        sum -= x[j] * mat[i][j];\n                    }\n                }\n                x[i] = sum / mat[i][i];\n            }\n        }\n        return x;\n    };\n    ;\n    Solver.getUpper = function (mat) {\n        var upper = [];\n        var lower = [];\n        for (var row = 0; row < mat.length; row++) {\n            var newLowerRow = [];\n            var newUpperRow = [];\n            for (var col = 0; col < mat[row].length; col++) {\n                if (row >= col) {\n                    newUpperRow.push(mat[row][col]);\n                    newLowerRow.push(0);\n                }\n                else {\n                    newUpperRow.push(0);\n                    newLowerRow.push(mat[row][col]);\n                }\n            }\n            upper.push(newUpperRow);\n            lower.push(newLowerRow);\n        }\n        return { 'lower': lower, 'upper': upper };\n    };\n    return Solver;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Solver.ts?");

/***/ }),

/***/ "./src/Utlis.ts":
/*!**********************!*\
  !*** ./src/Utlis.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Utils\": () => (/* binding */ Utils)\n/* harmony export */ });\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    Utils.randomColor = function () {\n        var letters = '0123456789ABCDEF';\n        var color = '#';\n        for (var i = 0; i < 6; i++) {\n            color += letters[Math.floor(Math.random() * 16)];\n        }\n        return color;\n    };\n    ;\n    return Utils;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Utlis.ts?");

/***/ }),

/***/ "./src/Vector.ts":
/*!***********************!*\
  !*** ./src/Vector.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec2\": () => (/* binding */ Vec2)\n/* harmony export */ });\nvar Vec2 = /** @class */ (function () {\n    function Vec2(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    ;\n    Vec2.prototype.transpose = function (x, y) {\n        return new Vec2(this.x + x, this.y + y);\n    };\n    ;\n    Vec2.prototype.rotate = function (theta) {\n        var rotatedX = this.x * Math.cos(theta) - this.y * Math.sin(theta);\n        var rotatedY = this.x * Math.sin(theta) + this.y * Math.cos(theta);\n        return new Vec2(rotatedX, rotatedY);\n    };\n    ;\n    Vec2.prototype.scale = function (s) {\n        return new Vec2(this.x * s, this.y * s);\n    };\n    ;\n    Vec2.prototype.sqrtMagnitude = function () {\n        return Math.sqrt(this.magnitude());\n    };\n    ;\n    Vec2.prototype.magnitude = function () {\n        return this.x * this.x + this.y * this.y;\n    };\n    ;\n    Vec2.prototype.sub = function (other) {\n        return new Vec2(this.x - other.x, this.y - other.y);\n    };\n    ;\n    Vec2.prototype.normalize = function () {\n        var len = this.sqrtMagnitude();\n        return new Vec2(this.x / len, this.y / len);\n    };\n    ;\n    Vec2.prototype.dot = function (other) {\n        return this.x * other.x + this.y * other.y;\n    };\n    ;\n    Vec2.prototype.cross = function (other) {\n        return this.x * other.y - this.y * other.x;\n    };\n    ;\n    Vec2.prototype.normal = function () {\n        return new Vec2(-this.y, this.x);\n    };\n    ;\n    Vec2.prototype.rightNormal = function () {\n        return new Vec2(this.y, -this.x);\n    };\n    ;\n    Vec2.prototype.add = function (other) {\n        return new Vec2(this.x + other.x, this.y + other.y);\n    };\n    ;\n    Vec2.prototype.pseudoCross = function (value) {\n        return new Vec2(-value * this.x, value * this.y);\n    };\n    Vec2.prototype.inv = function () {\n        return this.scale(-1);\n    };\n    Vec2.prototype.toArray = function () {\n        return [this.x, this.y];\n    };\n    Vec2.prototype.distance = function (other) {\n        return this.sub(other).sqrtMagnitude();\n    };\n    Vec2.ZERO = new Vec2(0, 0);\n    return Vec2;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Vector.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.Circle),\n/* harmony export */   \"Collision\": () => (/* reexport safe */ _Collision__WEBPACK_IMPORTED_MODULE_1__.Collision),\n/* harmony export */   \"Engine\": () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_3__.Engine),\n/* harmony export */   \"Graphics\": () => (/* reexport safe */ _Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics),\n/* harmony export */   \"Polygon\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.Polygon),\n/* harmony export */   \"Rectangle\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.Rectangle),\n/* harmony export */   \"RegularPolygon\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.RegularPolygon),\n/* harmony export */   \"Solver\": () => (/* reexport safe */ _Solver__WEBPACK_IMPORTED_MODULE_4__.Solver),\n/* harmony export */   \"Vec2\": () => (/* reexport safe */ _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2)\n/* harmony export */ });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n/* harmony import */ var _Collision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collision */ \"./src/Collision.ts\");\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Engine */ \"./src/Engine.ts\");\n/* harmony import */ var _Solver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Solver */ \"./src/Solver.ts\");\n/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Graphics */ \"./src/Graphics.ts\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://end3in/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	end3in = __webpack_exports__;
/******/ 	
/******/ })()
;