/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Body.js":
/*!*********************!*\
  !*** ./src/Body.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Vec2 = __webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\nconst Utils = __webpack_require__(/*! ./Utlis */ \"./src/Utlis.js\");\n\nconst Body = {};\n\n\n\nmodule.exports = Body;\n\n(function () {\n\n    const Type = {\n        Polygon: 'polygon',\n        Circle: 'circle'\n    }\n\n    Body.rect = function (width, height, x, y, options = {}) {\n        this.Type = Type\n        this.pos = Vec2.create(x, y);\n        this.rot = options.rot || 0.0;\n        this.points = [Vec2.create(-width / 2, height / 2),\n            Vec2.create(width / 2, height / 2),\n            Vec2.create(width / 2, -height / 2),\n            Vec2.create(-width / 2, -height / 2)];\n        this.width = width;\n        this.height = height;\n        this.v = Vec2.create(0, 0);\n        this.omega = 0.0;\n        if (options.isStatic) {\n            this.m = 0;\n            this.mInv = 0;\n            this.IInv = 0;\n        } else {\n            this.m = 900 * this.width * this.height;\n            this.mInv = 1.0 / this.m;\n            this.IInv = 12.0 / (this.m * (this.width * this.width + this.height + this.height));\n        }\n        this.restitution = 0.6\n        if (options.color) {\n            this.color = options.color\n        } else {\n            this.color = Utils.randomColor()\n        }\n        this.isStatic = options.isStatic || false;\n        this.type = Type.Polygon;\n        this.transformUpdateRequired = true;\n        this.transformedPoints = []\n        return Object.assign({}, this)\n    };\n\n    Body.polygon = function (vertices, x, y, options = {}) {\n        this.Type = Type\n        this.pos = Vec2.create(x, y);\n        this.rot = options.rot || 0.0;\n        this.points = [];\n        let meanX = vertices.map((o) => o[0]).reduce((p, c) => p + c, 0) / vertices.length;\n        let meanY = vertices.map((o) => o[1]).reduce((p, c) => p + c, 0) / vertices.length;\n        for (let pair of vertices) {\n            this.points.push(Vec2.create(pair[0] - meanX, pair[1] - meanY));\n        }\n        this.v = Vec2.create(0, 0);\n        this.omega = 0.0;\n        if (options.isStatic) {\n            this.m = 0;\n            this.mInv = 0;\n            this.IInv = 0;\n        } else {\n            let area = 0;\n            let last = this.points[this.points.length - 1];\n            for (let point of this.points) {\n                area += (last.x * point.y) - (last.y * point.x);\n                last = point\n            }\n            area /= 2.0;\n            this.m = 900 * Math.abs(area);\n            // approximate with circle\n            this.mInv = 1.0 / this.m;\n            const maxR = (Math.max.apply(Math, this.points.map((v) => (v.sqrtMagnitude()))));\n            this.IInv = 2 / (this.m * maxR * maxR);\n        }\n        this.restitution = 0.1\n        if (options.color) {\n            this.color = options.color\n        } else {\n            this.color = Utils.randomColor()\n        }\n        this.isStatic = options.isStatic || false;\n        this.type = Type.Polygon;\n        this.transformUpdateRequired = true;\n        this.transformedPoints = []\n        return Object.assign({}, this)\n    };\n\n    Body.regularPolygon = function (num_of_vertices, radius, x, y, options = {}) {\n        let positions = [];\n        for (let i = num_of_vertices - 1; i >= 0; i--) {\n            let pos_x = Math.cos(2.0 * Math.PI / num_of_vertices * i) * radius;\n            let pos_y = Math.sin(2.0 * Math.PI / num_of_vertices * i) * radius;\n            positions.push([pos_x, pos_y])\n        }\n        return Body.polygon(positions, x, y, options)\n    };\n\n    Body.circle = function (x, y, radius, options = {}) {\n        this.Type = Type.Circle\n        this.pos = Vec2.create(x, y);\n        this.rot = 0.0;\n        this.v = Vec2.create(0, 0);\n        this.omega = 0.0;\n        this.IInv = 0;\n        if (options.isStatic) {\n            this.m = 0;\n            this.mInv = 0;\n        } else {\n            let area = 2 * Math.PI * radius * radius;\n            this.m = 900 * area;\n            // aprox with circle\n            this.mInv = 1.0 / this.m;\n            this.IInv = 2 / (this.m * radius * radius);\n        }\n        if (options.color) {\n            this.color = options.color\n        } else {\n            this.color = Utils.randomColor()\n        }\n        this.isStatic = options.isStatic || false;\n        this.type = Type.Circle;\n        this.radius = radius;\n        this.restitution = 0.2\n        this.transformUpdateRequired = true;\n        this.transformedPoints = []\n        return Object.assign({}, this)\n    };\n\n    Body.update = function (dt) {\n        this.pos.x += this.v.x * dt;\n        this.pos.y += this.v.y * dt;\n        // this.rot += this.omega * dt;\n        this.transformUpdateRequired = true;\n    };\n\n    Body.applyForce = function (fx, fy, px, py, dt) {\n        px = px - this.pos.x;\n        py = py - this.pos.y;\n        let tau = px * fy - py * fx;\n        let ax = fx * this.mInv;\n        let ay = fy * this.mInv;\n        this.applyAcceleration(ax, ay, tau, dt)\n    };\n\n    Body.applyAcceleration = function (ax, ay, tau, dt) {\n        let alpha = tau * this.IInv;\n        this.v.x += ax * dt;\n        this.v.y -= ay * dt;\n        this.omega += alpha * dt;\n    };\n\n    Body.applyImpulse = function (P) {\n        if (this.isStatic) {\n            return\n        }\n        this.v.x -= P.x * this.mInv;\n        this.v.y -= P.y * this.mInv;\n        // this.omega -= this.IInv * r.cross(P);\n    };\n\n    Body.getTransformedPoints = function () {\n        if (this.transformUpdateRequired === false){\n            return this.transformedPoints\n        }\n        for (let i = 0; i < this.points.length; i++){\n            this.transformedPoints[i] = this.points[i].rotate(this.rot).add(this.pos)\n        }\n        this.transformUpdateRequired = false;\n        return this.transformedPoints;\n    };\n\n    Body.transformedAxes = function () {\n        let result = [];\n        for (let i = 0; i < this.getTransformedPoints().length; i++) {\n            let first = this.getTransformedPoints()[i];\n            let second = this.getTransformedPoints()[(i + 1) % this.getTransformedPoints().length];\n            result.push({axis: second.sub(first), p1: first, p2: second})\n        }\n        return result;\n    };\n\n    Body.isInside = function (point) {\n        for (let a of this.transformedAxes()) {\n            let d = a.axis.cross(a.p2.sub(point));\n            if (d > 0) return false;\n        }\n        return true;\n    };\n}());\n\n//# sourceURL=webpack://end3in/./src/Body.js?");

/***/ }),

/***/ "./src/Collision.js":
/*!**************************!*\
  !*** ./src/Collision.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Body = __webpack_require__(/*! ./Body */ \"./src/Body.js\");\n\nconst Collision = {};\n\nmodule.exports = Collision;\n\n(function () {\n    Collision.areColliding = function (body1, body2) {\n        if (body1.type !== body2.type) {\n            return false // TODO add more calculations\n        }\n        if (body1.type === Body.Type.Polygon) {\n            let body1MinX = Number.MAX_VALUE, body1MaxX = -Number.MAX_VALUE,\n                body2MinX = Number.MAX_VALUE, body2MaxX = -Number.MAX_VALUE,\n                body1MinY = Number.MAX_VALUE, body1MaxY = -Number.MAX_VALUE,\n                body2MinY = Number.MAX_VALUE, body2MaxY = -Number.MAX_VALUE;\n            for (let p of body1.getTransformedPoints()) {\n                body1MinX = Math.min(body1MinX, p.x)\n                body1MaxX = Math.max(body1MaxX, p.x);\n                body1MinY = Math.min(body1MinY, p.y);\n                body1MaxY = Math.max(body1MaxY, p.y);\n            }\n            for (let p of body2.getTransformedPoints()) {\n                body2MinX = Math.min(body2MinX, p.x);\n                body2MaxX = Math.max(body2MaxX, p.x);\n                body2MinY = Math.min(body2MinY, p.y);\n                body2MaxY = Math.max(body2MaxY, p.y);\n            }\n            return body1MinX < body2MaxX &&\n                body1MaxX > body2MinX &&\n                body1MinY < body2MaxY &&\n                body1MaxY > body2MinY;\n        } else if (body1.type === 'circle') {\n            return body1.pos.sub(body2.pos).sqrtMagnitude() < body1.radious + body2.radious;\n        }\n    };\n\n    Collision.calculateSAT = function (body1, body2, options = {}) {\n        if (body1.type === 'circle' || body2.type === 'circle') return null; // TODO add more calculations\n        let context = !options.debug || options.context;\n        let debug = options.debug || false;\n\n        function projectPoint(axis, point) {\n            return point.dot(axis);\n        }\n\n        function projectBody(axis, body) {\n            let min = Number.MAX_VALUE;\n            let max = -Number.MAX_VALUE;\n            let minPoint;\n            let maxPoint;\n            for (let point of body.getTransformedPoints()) {\n                let projection = projectPoint(axis, point);\n                if (min > projection) {\n                    min = projection;\n                    minPoint = point;\n                }\n                if (max < projection) {\n                    max = projection;\n                    maxPoint = point;\n                }\n            }\n            return {\"min\": min, \"max\": max, \"minPoint\": minPoint, \"maxPoint\": maxPoint};\n        }\n\n        function drawNormal(normal) {\n            context.strokeStyle = \"#000\";\n            context.lineWidth = 1;\n            normal = normal.normal();\n            context.beginPath();\n            let axisStart = normal.scale(-10 * graphics.scale).add(graphics.cameraPos.scale(graphics.scale));\n            context.moveTo(axisStart.x, axisStart.y);\n            let axisEnd = normal.scale(10 * graphics.scale).add(graphics.cameraPos.scale(graphics.scale));\n            context.lineTo(axisEnd.x, axisEnd.y);\n            context.stroke();\n        }\n\n        function drawProjection(normal, body, proj, color, width) {\n            context.strokeStyle = color;\n            context.lineWidth = width;\n            context.beginPath();\n            let axisStart = normal.scale(proj.max * graphics.scale).add(graphics.cameraPos.scale(graphics.scale));\n            context.moveTo(axisStart.x, axisStart.y);\n            let axisEnd = normal.copy().scale(proj.min * graphics.scale).add(graphics.cameraPos.scale(graphics.scale));\n            context.lineTo(axisEnd.x, axisEnd.y);\n            context.stroke();\n        }\n\n        function drawIncidentPoint(point1) {\n            context.strokeStyle = \"#FFF000\";\n            context.beginPath();\n            let point = graphics.worldToCanvasPosition(point1.add(graphics.cameraPos))\n            context.arc(point.x, point.y, 30, 0, 2 * Math.PI);\n            context.stroke();\n        }\n\n        let mtvAxis = null;\n        let mtvLength = Number.MAX_VALUE;\n        let refP1;\n        let refP2;\n        let incP1;\n        let incP2;\n        let incidentBody;\n        let referenceBody;\n        for (let body of [body1, body2]) {\n            for (let axisWithPoints of body.transformedAxes()) {\n                let axis = axisWithPoints.axis;\n\n                let normal = axis.normalize().normal();\n                let bProj = projectBody(normal, body1);\n                let oProj = projectBody(normal, body2);\n                if (debug) {\n                    drawNormal(normal);\n                    drawProjection(normal, body1, body2, \"#FF0000\", 10);\n                    drawProjection(normal, body1, body2, \"#00FF00\", 8);\n                }\n                // check overlap\n                if (bProj.max <= oProj.min ||\n                    bProj.min >= oProj.max) {\n                    return false\n                }\n                let overlap = 0;\n\n                overlap = Math.min(\n                    bProj.max - oProj.min,\n                    oProj.max - bProj.min\n                )\n\n                if (overlap < mtvLength) {\n                    mtvLength = overlap;\n                    mtvAxis = normal;\n                    referenceBody = body1;\n                    refP1 = axisWithPoints.p1;\n                    refP2 = axisWithPoints.p2;\n                    incidentBody = body2;\n                    incP1 = oProj.minPoint;\n                    incP2 = oProj.maxPoint;\n                }\n            }\n        }\n\n        if (referenceBody.pos.sub(incidentBody.pos).dot(mtvAxis) > 0) {\n            mtvAxis = mtvAxis.inv()\n        }\n        let penetratingPointInWorld = incP2\n\n        let penetratingPoint;\n        if (referenceBody.isInside(penetratingPointInWorld)) {\n            penetratingPoint = incP2;\n        } else {\n            penetratingPoint = incP1;\n        }\n        let edgePoint = penetratingPoint\n            .add(mtvAxis.normal().scale(mtvLength))\n\n        if(debug) {\n            drawIncidentPoint(penetratingPoint)\n        }\n\n        return {\n            'normal': mtvAxis,\n            'length': mtvLength,\n            'penetratingBody': incidentBody,\n            'refP1': refP1,\n            'refP2': refP2,\n            'referenceBody': referenceBody,\n            'referencePoint': edgePoint,\n            'penetratingPoint': penetratingPoint\n        };\n    }\n}());\n\n//# sourceURL=webpack://end3in/./src/Collision.js?");

/***/ }),

/***/ "./src/Engine.js":
/*!***********************!*\
  !*** ./src/Engine.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./Collision */ \"./src/Collision.js\");\n__webpack_require__(/*! ./Solver */ \"./src/Solver.js\");\n\nconst Engine = {};\n\nmodule.exports = Engine;\n\n(function () {\n\n    Engine.create = function (debug = false, solver = 'impulse') {\n        this.solver = solver;\n        this.dt = 1 / 60; // take dt from elapsed time\n        this.debug = debug;\n        this.g = -9.81;\n        this.gameObjects = [];\n        this.newBodyId = 0;\n        this.joints = [];\n        return Object.assign({}, this)\n    };\n\n    Engine.start = function () {\n        let self = this;\n        window.setInterval(function () {\n            self.update.call(self)\n        }, 1000 * self.dt);\n    };\n\n    Engine.update = function () {\n        for (let obj of this.gameObjects) {\n            if (obj.mInv !== 0) {\n                obj.applyAcceleration(0, this.g, 0, engine.dt);\n            }\n        }\n        if (this.solver === 'impulse') {\n            this.impulseSolver();\n        } else if (this.solver === 'constraint') {\n            this.constraintSolver();\n        } else if (this.solver === 'translation') {\n            this.translationSolver();\n        }\n        for (let obj of this.gameObjects) {\n            obj.update(this.dt);\n        }\n    };\n\n    Engine.addBody = function (body) {\n        body.bodyId = this.newBodyId;\n        this.newBodyId += 1;\n        this.gameObjects.push(body);\n    };\n\n    Engine.addAllBodies = function (bodies) {\n        for (let body of bodies) {\n            this.addBody(body)\n        }\n    };\n\n    Engine.translationSolver = function () {\n        for (let i = 0; i < engine.gameObjects.length; i++) {\n            for (let j = i + 1; j < engine.gameObjects.length; j++) {\n                const body1 = engine.gameObjects[i]\n                const body2 = engine.gameObjects[j]\n                if (body1.isStatic && body2.isStatic){\n                    continue\n                }\n                if (!Collision.areColliding(body1, body2)) {\n                    continue;\n                }\n                if (body1.type === Body.Type.Polygon) {\n                    if (body2.type === Body.Type.Polygon) {\n                        let mtv = Collision.calculateSAT(body1, body2);\n                        if (mtv !== false) {\n                            if (body2.isStatic) {\n                                body1.pos = body1.pos.add(mtv.normal.normalize().scale(-mtv.length))\n                            } else if (body1.isStatic) {\n                                body2.pos = body2.pos.add(mtv.normal.normalize().scale(mtv.length))\n                            } else {\n                                body2.pos = body2.pos.add(mtv.normal.normalize().scale(mtv.length / 2))\n                                body1.pos = body1.pos.add(mtv.normal.normalize().scale(-mtv.length / 2))\n                            }\n\n                            this.resolveCollision(body1, body2, mtv.normal)\n                        }\n                    } else {\n                        // todo\n                    }\n                } else {\n                    // todo\n                }\n            }\n        }\n    }\n\n    Engine.resolveCollision = function (body1, body2, normal){\n        const relativeVelocity = body2.v.sub(body1.v);\n\n        if (relativeVelocity.dot(normal) > 0) {\n            return;\n        }\n\n        const e = Math.min(body1.restitution, body2.restitution);\n\n        let j = -(1 + e) *  relativeVelocity.dot(normal)\n        j /= body1.mInv + body2.mInv;\n\n        const impulse = normal.scale(j);\n\n        body1.v = body1.v.sub(impulse.scale(body1.mInv));\n        body2.v = body2.v.add(impulse.scale(body2.mInv));\n    }\n\n    Engine.impulseSolver = function () {\n        for (let i = 0; i < this.gameObjects.length; i++) {\n            for (let j = i + 1; j < this.gameObjects.length; j++) {\n                let body1 = this.gameObjects[i]\n                let body2 = this.gameObjects[j]\n                if (!Collision.areColliding(body1, body2)) {\n                    continue;\n                }\n                if (body1.type === Body.Type.Circle && body1.type === Body.Type.Circle) { //TODO add more cases\n                    continue;\n                }\n                let mtv = Collision.calculateSAT(body1, body2);\n                if (mtv) {\n                    let incident = mtv.penetratingBody;\n                    let reference = mtv.referenceBody;\n                    // V + omega × r\n                    let penetratingVelocity = mtv.penetratingBody.v\n                        .add(mtv.penetratingPoint\n                            .normal()\n                            .scale(mtv.penetratingBody.omega))\n                        .cross(mtv.normal);\n                    let referenceVelocity = mtv.referenceBody.v\n                        .add(mtv.referencePoint\n                            .normal()\n                            .scale(mtv.referenceBody.omega))\n                        .cross(mtv.normal);\n\n                    let relativeVelocity = penetratingVelocity - referenceVelocity;\n                    let sign = Math.sign(relativeVelocity);\n                    relativeVelocity = Math.abs(relativeVelocity);\n\n                    let rn1 = mtv.penetratingPoint.cross(mtv.normal);\n                    let rn2 = mtv.referencePoint.cross(mtv.normal);\n\n                    let k = mtv.penetratingBody.mInv + mtv.referenceBody.mInv;\n                    k += mtv.penetratingBody.IInv * (rn1 * rn1);\n                    k += mtv.referenceBody.IInv * (rn2 * rn2);\n\n                    let slop = 0.02;\n                    let bias = 0.2 / this.dt * Math.max(mtv.length - slop, 0);\n                    let P = (relativeVelocity + sign * bias) / k;\n\n                    P = mtv.normal.scale(P).normal();\n\n                    let refVector = P.scale(sign);\n                    let indVector = P.scale(-1 * sign);\n                    incident.applyImpulse(indVector);\n                    reference.applyImpulse(refVector);\n                }\n            }\n        }\n    };\n    Engine.addJoint = function (joint) {\n        this.joints.push(joint)\n    };\n    Engine.addAllJoints = function (joints) {\n        for (let joint of joints) {\n            this.addJoint(joint);\n        }\n    };\n\n    Engine.constraintSolver = function () {\n        for (let i = 0; i < 4; i++) {\n            for (let c of this.joints) {\n                let J = [];\n                let pA = c.local1Anchor.rotate(c.body1.rot).transpose(c.body1.pos);\n                let pB = c.local1Anchor.rotate(c.body2.rot).transpose(c.body2.pos);\n                J.push(2 * (pA.x - pB.x),\n                    2 * (pA.y - pB.y),\n                    // 2 * pA.sub(pB).scale(-1).cross(pA.sub(c.body1.pos)),\n                    2 * (pB.x - pA.x),\n                    2 * (pB.y - pA.y),\n                    // 2 * pA.sub(pB).scale(-1).cross(pB.sub(c.body1.pos)),\n                );\n                let bias = (0.2 / this.dt) * pA.sub(pB).sqrtMagnitude();\n                // let lambda = -\n            }\n        }\n    };\n}());\n\n//# sourceURL=webpack://end3in/./src/Engine.js?");

/***/ }),

/***/ "./src/Graphics.js":
/*!*************************!*\
  !*** ./src/Graphics.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Vec2 = __webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\nconst Body = __webpack_require__(/*! ./Body */ \"./src/Body.js\");\n\nconst Graphics = {}\n\nmodule.exports = Graphics;\n\n(function () {\n    Graphics.started = false;\n\n    Graphics.create = function (width, height, engine, debug = false, scale  = 60, cameraPos = Vec2.create(3, 3), clickCallback = function () {\n    }) {\n        this.engine = engine\n        this.debug = debug\n        this.canvas = document.createElement('canvas')\n        document.body.appendChild(this.canvas)\n        let self = this\n        document.addEventListener(\"click\",\n            function (event) {\n                let worldPos = self.clientToWorldPos(Vec2.create(event.clientX, event.clientY))\n                clickCallback(worldPos)\n            });\n        this.ctx = this.canvas.getContext('2d');\n        this.scale = scale;\n        this.cameraPos = cameraPos;\n        this.width = 10 * this.scale;\n        this.height = 10 * this.scale;\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        this.dt = 1 / 60;\n        return Object.assign({}, this)\n    }\n\n    Graphics.start = function () {\n        this.started = true;\n        this.setInterval()\n    };\n\n    Graphics.setInterval = function () {\n        if (!this.started) {\n            return\n        }\n        const self = this;\n        setTimeout(function () {\n            self.drawBodies(self.engine.gameObjects)\n            self.setInterval()\n        }, 1000 * this.dt);\n    }\n\n    Graphics.stop = function () {\n        this.started = false;\n    }\n\n    Graphics.drawBodies = function (bodies = this.engine.gameObjects) {\n        this.clear()\n        this.ctx.save();\n        this.ctx.scale(this.scale, this.scale);\n        this.ctx.translate(this.cameraPos.x, this.cameraPos.y);\n        for (let body of bodies) {\n            this.drawBody(this.ctx, body, this.debug)\n        }\n        this.ctx.restore()\n    }\n\n    Graphics.clear = function () {\n        this.ctx.fillStyle = \"#FFFFFF\";\n        this.ctx.fillRect(0, 0, this.width, this.height);\n        this.ctx.fillStyle = \"#000000\";\n    };\n\n    Graphics.drawBody = function (ctx, body, debug) {\n        if (body.type === Body.Type.Polygon) {\n            ctx.beginPath();\n            for (let i = 0; i < body.points.length + 1; i++) {\n                let next = body.points[i % body.points.length]\n                    .rotate(body.rot)\n                    .transpose(body.pos.x, body.pos.y);\n                if (i === 0) {\n                    ctx.moveTo(next.x, next.y);\n                } else {\n                    ctx.lineTo(next.x, next.y)\n                }\n            }\n            ctx.fillStyle = body.color;\n            ctx.fill();\n            if (debug) {\n                for (let axis of body.transformedAxes()) {\n                    let mid = axis.axis.scale(0.5).add(axis.p1);\n                    let norm = axis.axis.normal();\n                    ctx.lineWidth = 1 / this.scale;\n                    ctx.strokeStyle = \"#7a7a7a\";\n                    ctx.beginPath();\n                    ctx.moveTo(mid.x, mid.y);\n                    ctx.lineTo(mid.x + norm.x, mid.y + norm.y);\n                    ctx.stroke()\n                }\n\n            }\n        } else if (body.type === Body.Type.Circle) {\n            ctx.lineWidth = 1 / this.scale;\n            ctx.beginPath();\n            ctx.arc(body.pos.x, body.pos.y, body.radius, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n    }\n\n    Graphics.clientToWorldPos = function (clientPos) {\n        const {top, left} = this.canvas.getBoundingClientRect()\n        return Vec2.create(clientPos.x, clientPos.y)\n            .sub(Vec2.create(top, left))\n            .scale(1 / this.scale)\n            .sub(this.cameraPos);\n    }\n\n    Graphics.worldToCanvasPosition = function (worldPos) {\n        return worldPos.scale(this.scale)\n    }\n})()\n\n//# sourceURL=webpack://end3in/./src/Graphics.js?");

/***/ }),

/***/ "./src/Joint.js":
/*!**********************!*\
  !*** ./src/Joint.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\n\nconst Joint = {};\n\nmodule.exports = Joint;\n\n(function () {\n    Joint.create = function (body1, body2, position) {\n        this.body1 = body1;\n        this.body2 = body2;\n        this.local1Anchor = position.sub(body1.pos).rotate(body1.rot);\n        this.local2Anchor = position.sub(body2.pos).rotate(body2.rot);\n        return Object.assign({}, this)\n    }\n}());\n\n//# sourceURL=webpack://end3in/./src/Joint.js?");

/***/ }),

/***/ "./src/Solver.js":
/*!***********************!*\
  !*** ./src/Solver.js ***!
  \***********************/
/***/ ((module) => {

eval("const Solver = {};\n\nmodule.exports = Solver;\n\n(function () {\n        Solver.solve = function (mat, b, iterations) {\n            // Ax = b\n            let x = [];\n            for (let i = 0; i < mat.length; i++) {\n                x.push(0);\n            }\n            for (let iter = 0; iter < iterations; iter++) {\n                for (let i = 0; i < mat.length; i++) {\n                    let sum = b[i];\n                    for (let j = 0; j < mat[i].length; j++) {\n                        if (j !== i) {\n                            sum -= x[j] * mat[i][j];\n                        }\n                    }\n                    x[i] = sum / mat[i][i];\n                }\n            }\n            return x;\n        };\n        Solver.getUpper = function (mat) {\n            let upper = [];\n            let lower = [];\n            for (let row = 0; row < mat.length; row++) {\n                let newLowerRow = [];\n                let newUpperRow = [];\n                for (let col = 0; col < max[row].length; col++) {\n                    if (row >= col) {\n                        newUpperRow.push(mat[row][col]);\n                        newLowerRow.push(0)\n                    } else {\n                        newUpperRow.push(0);\n                        newLowerRow.push(mat[row][col]);\n                    }\n                }\n                upper.push(newUpperRow);\n                lower.push(newLowerRow);\n            }\n            return {'lower': lower, 'upper': upper};\n        }\n    }()\n);\n\n//# sourceURL=webpack://end3in/./src/Solver.js?");

/***/ }),

/***/ "./src/Utlis.js":
/*!**********************!*\
  !*** ./src/Utlis.js ***!
  \**********************/
/***/ ((module) => {

eval("const Utils = {};\n\nmodule.exports = Utils;\n\n(function () {\n    Utils.randomColor = function () {\n        const letters = '0123456789ABCDEF';\n        let color = '#';\n        for (let i = 0; i < 6; i++) {\n            color += letters[Math.floor(Math.random() * 16)];\n        }\n        return color;\n    };\n})()\n\n//# sourceURL=webpack://end3in/./src/Utlis.js?");

/***/ }),

/***/ "./src/Vector.js":
/*!***********************!*\
  !*** ./src/Vector.js ***!
  \***********************/
/***/ ((module) => {

eval("const Vec2 = {};\n\nmodule.exports = Vec2;\n\n(function () {\n    Vec2.create = function (x, y) {\n        this.x = x;\n        this.y = y;\n        return Object.assign({}, this)\n    };\n\n    Vec2.transpose = function (x, y) {\n        return Vec2.create(this.x + x, this.y + y)\n    };\n\n    Vec2.rotate = function (theta) {\n        let rotatedX = this.x * Math.cos(theta) - this.y * Math.sin(theta);\n        let rotatedY = this.x * Math.sin(theta) + this.y * Math.cos(theta);\n        return Vec2.create(rotatedX, rotatedY);\n    };\n\n    Vec2.copy = function () {\n        return Vec2.create(this.x, this.y)\n    };\n\n    Vec2.scale = function (s) {\n        return Vec2.create(this.x * s, this.y * s);\n    };\n\n    Vec2.sqrtMagnitude = function () {\n        return Math.sqrt(this.magnitude());\n    };\n\n    Vec2.magnitude = function () {\n        return this.x * this.x + this.y * this.y;\n    };\n\n    Vec2.sub = function (other) {\n        return Vec2.create(this.x - other.x, this.y - other.y);\n    };\n\n    Vec2.normalize = function () {\n        let len = this.sqrtMagnitude();\n        return Vec2.create(this.x / len, this.y / len)\n    };\n\n    Vec2.dot = function (other) {\n        return this.x * other.x + this.y * other.y;\n    };\n\n    Vec2.cross = function (other) {\n        return this.x * other.y - this.y * other.x;\n    };\n\n    Vec2.normal = function () {\n        return Vec2.create(-this.y, this.x);\n    };\n\n    Vec2.rightNormal = function () {\n        return Vec2.create(this.y, -this.x);\n    };\n\n    Vec2.add = function (other) {\n        return Vec2.create(this.x + other.x, this.y + other.y);\n    };\n\n    Vec2.div = function (divider) {\n        return Vec2.create(this.x / divider, this.y / divider);\n    };\n\n    Vec2.pseudoCross = function (value) {\n        return Vec2.create(-value * this.x, value * this.y)\n    }\n\n    Vec2.inv = function () {\n        return this.scale(-1)\n    }\n\n    Vec2.toArray = function () {\n        return [this.x, this.y]\n    }\n}());\n\n//# sourceURL=webpack://end3in/./src/Vector.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("end3in = {};\n\nend3in.Vector = __webpack_require__(/*! ./Vector */ \"./src/Vector.js\");\nend3in.Collision = __webpack_require__(/*! ./Collision */ \"./src/Collision.js\");\nend3in.Body = __webpack_require__(/*! ./Body */ \"./src/Body.js\");\nend3in.Engine = __webpack_require__(/*! ./Engine */ \"./src/Engine.js\");\nend3in.Solver = __webpack_require__(/*! ./Solver */ \"./src/Solver.js\");\nend3in.Joint = __webpack_require__(/*! ./Joint */ \"./src/Joint.js\");\nend3in.Graphics = __webpack_require__(/*! ./Graphics */ \"./src/Graphics.js\");\n\n//# sourceURL=webpack://end3in/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;