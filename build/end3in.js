/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var end3in;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Body.ts":
/*!*********************!*\
  !*** ./src/Body.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Body\": () => (/* binding */ Body),\n/* harmony export */   \"Circle\": () => (/* binding */ Circle),\n/* harmony export */   \"Polygon\": () => (/* binding */ Polygon),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"RegularPolygon\": () => (/* binding */ RegularPolygon),\n/* harmony export */   \"Type\": () => (/* binding */ Type)\n/* harmony export */ });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n__webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\nvar Utils = __webpack_require__(/*! ./Utlis */ \"./src/Utlis.js\");\nvar Type;\n(function (Type) {\n    Type[Type[\"Polygon\"] = 0] = \"Polygon\";\n    Type[Type[\"Circle\"] = 1] = \"Circle\";\n})(Type || (Type = {}));\nvar Body = /** @class */ (function () {\n    function Body(x, y, mass, inertia, type, isStatic, rot, restitution, color) {\n        if (isStatic === void 0) { isStatic = false; }\n        if (rot === void 0) { rot = 0; }\n        if (restitution === void 0) { restitution = 0.5; }\n        if (color === void 0) { color = Utils.randomColor(); }\n        this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(x, y);\n        this.type = type;\n        this.rot = rot;\n        this.isStatic = isStatic;\n        if (this.isStatic) {\n            this.massInv = 0;\n            this.inertiaInv = 0;\n        }\n        else {\n            this.massInv = 1 / mass;\n            this.inertiaInv = 1 / inertia;\n        }\n        this.restitution = restitution;\n        this.color = color;\n        this.v = _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2.ZERO;\n        this.omega = 0;\n        this.transformUpdateRequired = true;\n    }\n    Body.prototype.update = function (dt) {\n        this.pos = this.pos.add(this.v.scale(dt));\n        // this.rot += this.omega * dt;\n        this.transformUpdateRequired = true;\n    };\n    ;\n    Body.prototype.applyForce = function (fx, fy, px, py, dt) {\n        px = px - this.pos.x;\n        py = py - this.pos.y;\n        var tau = px * fy - py * fx;\n        var ax = fx * this.massInv;\n        var ay = fy * this.massInv;\n        this.applyAcceleration(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(ax, ay), tau, dt);\n    };\n    ;\n    Body.prototype.applyAcceleration = function (a, tau, dt) {\n        var alpha = tau * this.inertiaInv;\n        this.v = this.v.add(a.scale(dt));\n        this.omega += alpha * dt;\n    };\n    ;\n    Body.prototype.applyImpulse = function (P) {\n        if (this.isStatic) {\n            return;\n        }\n        this.v = this.v.sub(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(P.x * this.massInv, P.y * this.massInv));\n        // this.omega -= this.inertiaInv * r.cross(P);\n    };\n    ;\n    return Body;\n}());\n\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    function Polygon(points, x, y, mass, isStatic, rot) {\n        var _this = this;\n        var vertices = points.map(function (p) { return new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(p[0], p[1]); });\n        var maxR = (Math.max.apply(Math, vertices.map(function (v) { return (v.sqrtMagnitude()); })));\n        var inertia = (mass * maxR * maxR) / 2;\n        _this = _super.call(this, x, y, mass, inertia, Type.Polygon, isStatic, rot) || this;\n        _this.points = [];\n        _this._transformedPoints = [];\n        var area = 0;\n        for (var i = 0; i < vertices.length; i++) {\n            var point = vertices[i];\n            var next = vertices[i % vertices.length];\n            area += (point.x * next.y) - (point.y * next.x);\n        }\n        area /= 2.0;\n        _this.area = area;\n        var meanX = vertices.map(function (o) { return o.x; }).reduce(function (p, c) { return p + c; }, 0) / points.length;\n        var meanY = vertices.map(function (o) { return o.y; }).reduce(function (p, c) { return p + c; }, 0) / points.length;\n        for (var _i = 0, vertices_1 = vertices; _i < vertices_1.length; _i++) {\n            var point = vertices_1[_i];\n            _this.points.push(new _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2(point.x - meanX, point.y - meanY));\n        }\n        return _this;\n    }\n    Object.defineProperty(Polygon.prototype, \"transformedPoints\", {\n        get: function () {\n            if (this.transformUpdateRequired === false) {\n                return this._transformedPoints;\n            }\n            for (var i = 0; i < this.points.length; i++) {\n                this._transformedPoints[i] = this.points[i].rotate(this.rot).add(this.pos);\n            }\n            this.transformUpdateRequired = false;\n            return this._transformedPoints;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ;\n    Object.defineProperty(Polygon.prototype, \"transformedAxes\", {\n        get: function () {\n            var result = [];\n            for (var i = 0; i < this.transformedPoints.length; i++) {\n                var first = this.transformedPoints[i];\n                var second = this.transformedPoints[(i + 1) % this.transformedPoints.length];\n                result.push({ axis: second.sub(first), p1: first, p2: second });\n            }\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ;\n    Polygon.prototype.isInside = function (point) {\n        for (var _i = 0, _a = this.transformedAxes; _i < _a.length; _i++) {\n            var a = _a[_i];\n            var d = a.axis.cross(a.p2.sub(point));\n            if (d > 0)\n                return false;\n        }\n        return true;\n    };\n    return Polygon;\n}(Body));\n\nvar RegularPolygon = /** @class */ (function (_super) {\n    __extends(RegularPolygon, _super);\n    function RegularPolygon(num_of_vertices, radius, x, y, mass, isStatic, rot) {\n        var points = [];\n        for (var i = num_of_vertices - 1; i >= 0; i--) {\n            var pos_x = Math.cos(2.0 * Math.PI / num_of_vertices * i) * radius;\n            var pos_y = Math.sin(2.0 * Math.PI / num_of_vertices * i) * radius;\n            points.push([pos_x, pos_y]);\n        }\n        return _super.call(this, points, x, y, mass, isStatic, rot) || this;\n    }\n    ;\n    return RegularPolygon;\n}(Polygon));\n\nvar Rectangle = /** @class */ (function (_super) {\n    __extends(Rectangle, _super);\n    function Rectangle(width, height, x, y, mass, isStatic, rot) {\n        var points = [[-width / 2, height / 2],\n            [width / 2, height / 2],\n            [width / 2, -height / 2],\n            [-width / 2, -height / 2]];\n        return _super.call(this, points, x, y, mass, isStatic, rot) || this;\n    }\n    return Rectangle;\n}(Polygon));\n\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle(x, y, radius, mass) {\n        var _this = this;\n        var inertia = 2 / (mass * radius * radius);\n        _this = _super.call(this, x, y, mass, inertia, Type.Circle) || this;\n        _this.radius = radius;\n        return _this;\n    }\n    Circle.prototype.isInside = function (point) {\n        return false;\n    };\n    return Circle;\n}(Body));\n\n\n\n//# sourceURL=webpack://end3in/./src/Body.ts?");

/***/ }),

/***/ "./src/Collision.ts":
/*!**************************!*\
  !*** ./src/Collision.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Collision\": () => (/* binding */ Collision)\n/* harmony export */ });\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n\nvar Collision = /** @class */ (function () {\n    function Collision() {\n    }\n    Collision.areColliding = function (body1, body2) {\n        if (body1.type !== body2.type) {\n            return false; // TODO add more calculations\n        }\n        if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon && body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n            var body1MinX = Number.MAX_VALUE, body1MaxX = -Number.MAX_VALUE, body2MinX = Number.MAX_VALUE, body2MaxX = -Number.MAX_VALUE, body1MinY = Number.MAX_VALUE, body1MaxY = -Number.MAX_VALUE, body2MinY = Number.MAX_VALUE, body2MaxY = -Number.MAX_VALUE;\n            for (var _i = 0, _a = body1.transformedPoints; _i < _a.length; _i++) {\n                var p = _a[_i];\n                body1MinX = Math.min(body1MinX, p.x);\n                body1MaxX = Math.max(body1MaxX, p.x);\n                body1MinY = Math.min(body1MinY, p.y);\n                body1MaxY = Math.max(body1MaxY, p.y);\n            }\n            for (var _b = 0, _c = body2.transformedPoints; _b < _c.length; _b++) {\n                var p = _c[_b];\n                body2MinX = Math.min(body2MinX, p.x);\n                body2MaxX = Math.max(body2MaxX, p.x);\n                body2MinY = Math.min(body2MinY, p.y);\n                body2MaxY = Math.max(body2MaxY, p.y);\n            }\n            return body1MinX < body2MaxX &&\n                body1MaxX > body2MinX &&\n                body1MinY < body2MaxY &&\n                body1MaxY > body2MinY;\n        }\n        else if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle && body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle) {\n            return body1.pos.sub(body2.pos).sqrtMagnitude() < body1.radius + body2.radius;\n        }\n    };\n    ;\n    Collision.calculateSAT = function (body1, body2) {\n        if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle || body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Circle)\n            return null; // TODO add more calculations\n        function projectPoint(axis, point) {\n            return point.dot(axis);\n        }\n        function projectBody(axis, body) {\n            var min = Number.MAX_VALUE;\n            var max = -Number.MAX_VALUE;\n            var minPoint;\n            var maxPoint;\n            for (var _i = 0, _a = body.transformedPoints; _i < _a.length; _i++) {\n                var point = _a[_i];\n                var projection = projectPoint(axis, point);\n                if (min > projection) {\n                    min = projection;\n                    minPoint = point;\n                }\n                if (max < projection) {\n                    max = projection;\n                    maxPoint = point;\n                }\n            }\n            return { \"min\": min, \"max\": max, \"minPoint\": minPoint, \"maxPoint\": maxPoint };\n        }\n        if (body1 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon && body2 instanceof _Body__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\n            var mtvAxis = null;\n            var mtvLength = Number.MAX_VALUE;\n            var refP1 = void 0;\n            var refP2 = void 0;\n            var incP1 = void 0;\n            var incP2 = void 0;\n            var incidentBody = void 0;\n            var referenceBody = void 0;\n            for (var _i = 0, _a = [body1, body2]; _i < _a.length; _i++) {\n                var body = _a[_i];\n                for (var _b = 0, _c = body.transformedAxes; _b < _c.length; _b++) {\n                    var axisWithPoints = _c[_b];\n                    var axis = axisWithPoints.axis;\n                    var normal = axis.normalize().normal();\n                    var bProj = projectBody(normal, body1);\n                    var oProj = projectBody(normal, body2);\n                    // check overlap\n                    if (bProj.max <= oProj.min ||\n                        bProj.min >= oProj.max) {\n                        return false;\n                    }\n                    var overlap = 0;\n                    overlap = Math.min(bProj.max - oProj.min, oProj.max - bProj.min);\n                    if (overlap < mtvLength) {\n                        mtvLength = overlap;\n                        mtvAxis = normal;\n                        referenceBody = body1;\n                        refP1 = axisWithPoints.p1;\n                        refP2 = axisWithPoints.p2;\n                        incidentBody = body2;\n                        incP1 = oProj.minPoint;\n                        incP2 = oProj.maxPoint;\n                    }\n                }\n            }\n            if (referenceBody.pos.sub(incidentBody.pos).dot(mtvAxis) > 0) {\n                mtvAxis = mtvAxis.inv();\n            }\n            var penetratingPointInWorld = incP2;\n            var penetratingPoint = void 0;\n            if (referenceBody.isInside(penetratingPointInWorld)) {\n                penetratingPoint = incP2;\n            }\n            else {\n                penetratingPoint = incP1;\n            }\n            var edgePoint = penetratingPoint\n                .add(mtvAxis.normal().scale(mtvLength));\n            return {\n                'normal': mtvAxis,\n                'length': mtvLength,\n                'penetratingBody': incidentBody,\n                'refP1': refP1,\n                'refP2': refP2,\n                'referenceBody': referenceBody,\n                'referencePoint': edgePoint,\n                'penetratingPoint': penetratingPoint\n            };\n        }\n    };\n    return Collision;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Collision.ts?");

/***/ }),

/***/ "./src/Solver.ts":
/*!***********************!*\
  !*** ./src/Solver.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Solver\": () => (/* binding */ Solver)\n/* harmony export */ });\nvar Solver = /** @class */ (function () {\n    function Solver() {\n    }\n    Solver.solve = function (mat, b, iterations) {\n        // Ax = b\n        var x = [];\n        for (var i = 0; i < mat.length; i++) {\n            x.push(0);\n        }\n        for (var iter = 0; iter < iterations; iter++) {\n            for (var i = 0; i < mat.length; i++) {\n                var sum = b[i];\n                for (var j = 0; j < mat[i].length; j++) {\n                    if (j !== i) {\n                        sum -= x[j] * mat[i][j];\n                    }\n                }\n                x[i] = sum / mat[i][i];\n            }\n        }\n        return x;\n    };\n    ;\n    Solver.getUpper = function (mat) {\n        var upper = [];\n        var lower = [];\n        for (var row = 0; row < mat.length; row++) {\n            var newLowerRow = [];\n            var newUpperRow = [];\n            for (var col = 0; col < mat[row].length; col++) {\n                if (row >= col) {\n                    newUpperRow.push(mat[row][col]);\n                    newLowerRow.push(0);\n                }\n                else {\n                    newUpperRow.push(0);\n                    newLowerRow.push(mat[row][col]);\n                }\n            }\n            upper.push(newUpperRow);\n            lower.push(newLowerRow);\n        }\n        return { 'lower': lower, 'upper': upper };\n    };\n    return Solver;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Solver.ts?");

/***/ }),

/***/ "./src/Vector.ts":
/*!***********************!*\
  !*** ./src/Vector.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec2\": () => (/* binding */ Vec2)\n/* harmony export */ });\nvar Vec2 = /** @class */ (function () {\n    function Vec2(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    ;\n    Vec2.prototype.transpose = function (x, y) {\n        return new Vec2(this.x + x, this.y + y);\n    };\n    ;\n    Vec2.prototype.rotate = function (theta) {\n        var rotatedX = this.x * Math.cos(theta) - this.y * Math.sin(theta);\n        var rotatedY = this.x * Math.sin(theta) + this.y * Math.cos(theta);\n        return new Vec2(rotatedX, rotatedY);\n    };\n    ;\n    Vec2.prototype.scale = function (s) {\n        return new Vec2(this.x * s, this.y * s);\n    };\n    ;\n    Vec2.prototype.sqrtMagnitude = function () {\n        return Math.sqrt(this.magnitude());\n    };\n    ;\n    Vec2.prototype.magnitude = function () {\n        return this.x * this.x + this.y * this.y;\n    };\n    ;\n    Vec2.prototype.sub = function (other) {\n        return new Vec2(this.x - other.x, this.y - other.y);\n    };\n    ;\n    Vec2.prototype.normalize = function () {\n        var len = this.sqrtMagnitude();\n        return new Vec2(this.x / len, this.y / len);\n    };\n    ;\n    Vec2.prototype.dot = function (other) {\n        return this.x * other.x + this.y * other.y;\n    };\n    ;\n    Vec2.prototype.cross = function (other) {\n        return this.x * other.y - this.y * other.x;\n    };\n    ;\n    Vec2.prototype.normal = function () {\n        return new Vec2(-this.y, this.x);\n    };\n    ;\n    Vec2.prototype.rightNormal = function () {\n        return new Vec2(this.y, -this.x);\n    };\n    ;\n    Vec2.prototype.add = function (other) {\n        return new Vec2(this.x + other.x, this.y + other.y);\n    };\n    ;\n    Vec2.prototype.pseudoCross = function (value) {\n        return new Vec2(-value * this.x, value * this.y);\n    };\n    Vec2.prototype.inv = function () {\n        return this.scale(-1);\n    };\n    Vec2.prototype.toArray = function () {\n        return [this.x, this.y];\n    };\n    Vec2.ZERO = new Vec2(0, 0);\n    return Vec2;\n}());\n\n\n\n//# sourceURL=webpack://end3in/./src/Vector.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.Circle),\n/* harmony export */   \"Collision\": () => (/* reexport safe */ _Collision__WEBPACK_IMPORTED_MODULE_1__.Collision),\n/* harmony export */   \"Engine\": () => (/* reexport safe */ _Engine__WEBPACK_IMPORTED_MODULE_3__.Engine),\n/* harmony export */   \"Graphics\": () => (/* reexport safe */ _Graphics__WEBPACK_IMPORTED_MODULE_6__.Graphics),\n/* harmony export */   \"Joint\": () => (/* reexport safe */ _Joint__WEBPACK_IMPORTED_MODULE_5__.Joint),\n/* harmony export */   \"Polygon\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.Polygon),\n/* harmony export */   \"Rectangle\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.Rectangle),\n/* harmony export */   \"RegularPolygon\": () => (/* reexport safe */ _Body__WEBPACK_IMPORTED_MODULE_2__.RegularPolygon),\n/* harmony export */   \"Solver\": () => (/* reexport safe */ _Solver__WEBPACK_IMPORTED_MODULE_4__.Solver),\n/* harmony export */   \"Vec2\": () => (/* reexport safe */ _Vector__WEBPACK_IMPORTED_MODULE_0__.Vec2)\n/* harmony export */ });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n/* harmony import */ var _Collision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collision */ \"./src/Collision.ts\");\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n/* harmony import */ var _Engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Engine */ \"./src/Engine.js\");\n/* harmony import */ var _Solver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Solver */ \"./src/Solver.ts\");\n/* harmony import */ var _Joint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Joint */ \"./src/Joint.js\");\n/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Graphics */ \"./src/Graphics.js\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://end3in/./src/main.ts?");

/***/ }),

/***/ "./src/Engine.js":
/*!***********************!*\
  !*** ./src/Engine.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Engine\": () => (/* binding */ Engine)\n/* harmony export */ });\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n\n\n\nconst {Collision} = __webpack_require__(/*! ./Collision */ \"./src/Collision.ts\");\n__webpack_require__(/*! ./Solver */ \"./src/Solver.ts\");\n\nclass Engine {\n    constructor(debug = false, solver = 'impulse', iterations = 1) {\n        this.solver = solver;\n        this.dt = 1 / 60; // take dt from elapsed time\n        this.debug = debug;\n        this.g = 9.81;\n        this.gameObjects = [];\n        this.newBodyId = 0;\n        this.joints = [];\n        this.iterations = iterations\n    };\n\n    start() {\n        let self = this;\n        window.setInterval(function () {\n            self.update.call(self)\n        }, 1000 * self.dt);\n    };\n\n    update() {\n        for (let obj of this.gameObjects) {\n            if (obj.isStatic !== true) {\n                obj.applyAcceleration(new _Vector__WEBPACK_IMPORTED_MODULE_1__.Vec2(0, this.g), 0, engine.dt);\n            }\n        }\n        if (this.solver === 'impulse') {\n            this.impulseSolver();\n        } else if (this.solver === 'constraint') {\n            this.constraintSolver();\n        } else if (this.solver === 'translation') {\n            this.translationSolver();\n        }\n        for (let obj of this.gameObjects) {\n            obj.update(this.dt);\n        }\n    };\n\n    addBody(body) {\n        body.bodyId = this.newBodyId;\n        this.newBodyId += 1;\n        this.gameObjects.push(body);\n    };\n\n    addAllBodies(bodies) {\n        for (let body of bodies) {\n            this.addBody(body)\n        }\n    };\n\n    translationSolver() {\n        for (let it = 0; it < this.iterations; it++) {\n            for (let i = 0; i < engine.gameObjects.length; i++) {\n                for (let j = i + 1; j < engine.gameObjects.length; j++) {\n                    const body1 = engine.gameObjects[i]\n                    const body2 = engine.gameObjects[j]\n                    if (body1.isStatic && body2.isStatic) {\n                        continue\n                    }\n                    if (!Collision.areColliding(body1, body2)) {\n                        continue;\n                    }\n                    if (body1.type === _Body__WEBPACK_IMPORTED_MODULE_0__.Type.Polygon) {\n                        if (body2.type === _Body__WEBPACK_IMPORTED_MODULE_0__.Type.Polygon) {\n                            let mtv = Collision.calculateSAT(body1, body2);\n                            if (mtv !== false) {\n                                if (body2.isStatic) {\n                                    body1.pos = body1.pos.add(mtv.normal.normalize().scale(-mtv.length))\n                                } else if (body1.isStatic) {\n                                    body2.pos = body2.pos.add(mtv.normal.normalize().scale(mtv.length))\n                                } else {\n                                    body2.pos = body2.pos.add(mtv.normal.normalize().scale(mtv.length / 2))\n                                    body1.pos = body1.pos.add(mtv.normal.normalize().scale(-mtv.length / 2))\n                                }\n\n                                this.resolveCollision(body1, body2, mtv.normal)\n                            }\n                        } else {\n                            // todo\n                        }\n                    } else {\n                        // todo\n                    }\n                }\n            }\n        }\n    }\n\n    resolveCollision(body1, body2, normal) {\n        const relativeVelocity = body2.v.sub(body1.v);\n\n        if (relativeVelocity.dot(normal) > 0) {\n            return;\n        }\n\n        const e = Math.min(body1.restitution, body2.restitution);\n\n        let j = -(1 + e) * relativeVelocity.dot(normal)\n        j /= body1.massInv + body2.massInv;\n\n        const impulse = normal.scale(j);\n\n        body1.v = body1.v.sub(impulse.scale(body1.massInv));\n        body2.v = body2.v.add(impulse.scale(body2.massInv));\n    }\n\n    impulseSolver() {\n        for (let i = 0; i < this.gameObjects.length; i++) {\n            for (let j = i + 1; j < this.gameObjects.length; j++) {\n                let body1 = this.gameObjects[i]\n                let body2 = this.gameObjects[j]\n                if (!Collision.areColliding(body1, body2)) {\n                    continue;\n                }\n                if (body1.type === _Body__WEBPACK_IMPORTED_MODULE_0__.Type.Circle && body1.type === _Body__WEBPACK_IMPORTED_MODULE_0__.Type.Circle) { //TODO add more cases\n                    continue;\n                }\n                let mtv = Collision.calculateSAT(body1, body2);\n                if (mtv) {\n                    let incident = mtv.penetratingBody;\n                    let reference = mtv.referenceBody;\n                    // V + omega × r\n                    let penetratingVelocity = mtv.penetratingBody.v\n                        .add(mtv.penetratingPoint\n                            .normal()\n                            .scale(mtv.penetratingBody.omega))\n                        .cross(mtv.normal);\n                    let referenceVelocity = mtv.referenceBody.v\n                        .add(mtv.referencePoint\n                            .normal()\n                            .scale(mtv.referenceBody.omega))\n                        .cross(mtv.normal);\n\n                    let relativeVelocity = penetratingVelocity - referenceVelocity;\n                    let sign = Math.sign(relativeVelocity);\n                    relativeVelocity = Math.abs(relativeVelocity);\n\n                    let rn1 = mtv.penetratingPoint.cross(mtv.normal);\n                    let rn2 = mtv.referencePoint.cross(mtv.normal);\n\n                    let k = mtv.penetratingBody.massInv + mtv.referenceBody.massInv;\n                    k += mtv.penetratingBody.inertiaInv * (rn1 * rn1);\n                    k += mtv.referenceBody.inertiaInv * (rn2 * rn2);\n\n                    let slop = 0.02;\n                    let bias = 0.2 / this.dt * Math.max(mtv.length - slop, 0);\n                    let P = (relativeVelocity + sign * bias) / k;\n\n                    P = mtv.normal.scale(P).normal();\n\n                    let refVector = P.scale(sign);\n                    let indVector = P.scale(-1 * sign);\n                    incident.applyImpulse(indVector);\n                    reference.applyImpulse(refVector);\n                }\n            }\n        }\n    };\n\n    addJoint(joint) {\n        this.joints.push(joint)\n    };\n\n    addAllJoints(joints) {\n        for (let joint of joints) {\n            this.addJoint(joint);\n        }\n    };\n\n    constraintSolver() {\n        for (let i = 0; i < 4; i++) {\n            for (let c of this.joints) {\n                let J = [];\n                let pA = c.local1Anchor.rotate(c.body1.rot).transpose(c.body1.pos);\n                let pB = c.local1Anchor.rotate(c.body2.rot).transpose(c.body2.pos);\n                J.push(2 * (pA.x - pB.x),\n                    2 * (pA.y - pB.y),\n                    // 2 * pA.sub(pB).scale(-1).cross(pA.sub(c.body1.pos)),\n                    2 * (pB.x - pA.x),\n                    2 * (pB.y - pA.y),\n                    // 2 * pA.sub(pB).scale(-1).cross(pB.sub(c.body1.pos)),\n                );\n                let bias = (0.2 / this.dt) * pA.sub(pB).sqrtMagnitude();\n                // let lambda = -\n            }\n        }\n    };\n}\n\n//# sourceURL=webpack://end3in/./src/Engine.js?");

/***/ }),

/***/ "./src/Graphics.js":
/*!*************************!*\
  !*** ./src/Graphics.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graphics\": () => (/* binding */ Graphics)\n/* harmony export */ });\nconst { Vec2 } = __webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\nconst Body = __webpack_require__(/*! ./Body */ \"./src/Body.ts\");\n\nclass Graphics {\n    started = false;\n\n    constructor(width, height, engine, debug = false, scale = 60, cameraPos = new Vec2(3, 3), clickCallback = function () {\n    }) {\n        this.engine = engine\n        this.debug = debug\n        this.canvas = document.createElement('canvas')\n        document.body.appendChild(this.canvas)\n        let self = this\n        document.addEventListener(\"click\",\n            function (event) {\n                let worldPos = self.clientToWorldPos(new Vec2(event.clientX, event.clientY))\n                clickCallback(worldPos)\n            });\n        this.ctx = this.canvas.getContext('2d');\n        this.scale = scale;\n        this.cameraPos = cameraPos;\n        this.width = 10 * this.scale;\n        this.height = 10 * this.scale;\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        this.dt = 1 / 60;\n    }\n\n    start() {\n        this.started = true;\n        this.setInterval()\n    };\n\n    setInterval() {\n        if (!this.started) {\n            return\n        }\n        const self = this;\n        setTimeout(function () {\n            self.drawBodies(self.engine.gameObjects)\n            self.setInterval()\n        }, 1000 * this.dt);\n    }\n\n    stop() {\n        this.started = false;\n    }\n\n    drawBodies(bodies = this.engine.gameObjects) {\n        this.clear()\n        this.ctx.save();\n        this.ctx.scale(this.scale, this.scale);\n        this.ctx.translate(this.cameraPos.x, this.cameraPos.y);\n        for (let body of bodies) {\n            this.drawBody(this.ctx, body, this.debug)\n        }\n        this.ctx.restore()\n    }\n\n    clear() {\n        this.ctx.fillStyle = \"#FFFFFF\";\n        this.ctx.fillRect(0, 0, this.width, this.height);\n        this.ctx.fillStyle = \"#000000\";\n    };\n\n    drawBody(ctx, body, debug) {\n        if (body.type === Body.Type.Polygon) {\n            ctx.beginPath();\n            for (let i = 0; i < body.points.length + 1; i++) {\n                let next = body.points[i % body.points.length]\n                    .rotate(body.rot)\n                    .transpose(body.pos.x, body.pos.y);\n                if (i === 0) {\n                    ctx.moveTo(next.x, next.y);\n                } else {\n                    ctx.lineTo(next.x, next.y)\n                }\n            }\n            ctx.fillStyle = body.color;\n            ctx.fill();\n            if (debug) {\n                for (let axis of body.transformedAxes) {\n                    let mid = axis.axis.scale(0.5).add(axis.p1);\n                    let norm = axis.axis.normal();\n                    ctx.lineWidth = 1 / this.scale;\n                    ctx.strokeStyle = \"#7a7a7a\";\n                    ctx.beginPath();\n                    ctx.moveTo(mid.x, mid.y);\n                    ctx.lineTo(mid.x + norm.x, mid.y + norm.y);\n                    ctx.stroke()\n                }\n\n            }\n        } else if (body.type === Body.Type.Circle) {\n            ctx.lineWidth = 1 / this.scale;\n            ctx.beginPath();\n            ctx.arc(body.pos.x, body.pos.y, body.radius, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n    }\n\n    clientToWorldPos(clientPos) {\n        const {top, left} = this.canvas.getBoundingClientRect()\n        return new Vec2(clientPos.x, clientPos.y)\n            .sub(new Vec2(top, left))\n            .scale(1 / this.scale)\n            .sub(this.cameraPos);\n    }\n\n    worldToCanvasPosition(worldPos) {\n        return worldPos.scale(this.scale)\n    }\n}\n\n//# sourceURL=webpack://end3in/./src/Graphics.js?");

/***/ }),

/***/ "./src/Joint.js":
/*!**********************!*\
  !*** ./src/Joint.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Joint\": () => (/* binding */ Joint)\n/* harmony export */ });\n__webpack_require__(/*! ./Vector */ \"./src/Vector.ts\");\n\nclass Joint {\n    constructor(body1, body2, position) {\n        this.body1 = body1;\n        this.body2 = body2;\n        this.local1Anchor = position.sub(body1.pos).rotate(body1.rot);\n        this.local2Anchor = position.sub(body2.pos).rotate(body2.rot);\n        return Object.assign({}, this)\n    }\n}\n\n//# sourceURL=webpack://end3in/./src/Joint.js?");

/***/ }),

/***/ "./src/Utlis.js":
/*!**********************!*\
  !*** ./src/Utlis.js ***!
  \**********************/
/***/ ((module) => {

eval("const Utils = {};\n\nmodule.exports = Utils;\n\n(function () {\n    Utils.randomColor = function () {\n        const letters = '0123456789ABCDEF';\n        let color = '#';\n        for (let i = 0; i < 6; i++) {\n            color += letters[Math.floor(Math.random() * 16)];\n        }\n        return color;\n    };\n})()\n\n//# sourceURL=webpack://end3in/./src/Utlis.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	end3in = __webpack_exports__;
/******/ 	
/******/ })()
;